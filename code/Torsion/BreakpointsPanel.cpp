// Torsion TorqueScript IDE - Copyright (C) Sickhead Games, LLC
// This file is subject to the terms and conditions defined in
// file 'LICENSE.txt', which is part of this source code package.

// Generated by DialogBlocks (unregistered), 09/22/05 13:31:37

#if defined(__GNUG__) && !defined(__APPLE__)
#pragma implementation "BreakpointsPanel.h"
#endif

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

////@begin includes
////@end includes

#include "MainFrame.h"
#include "BreakpointsPanel.h"
#include "Breakpoint.h"
#include "ProjectDoc.h"
#include "BreakpointPropertyDlg.h"
#include "tsToolBar.h"
#include "Icons.h"

////@begin XPM images
////@end XPM images

/*!
 * BreakpointsPanel type definition
 */

IMPLEMENT_DYNAMIC_CLASS( BreakpointsPanel, wxPanel )

/*!
 * BreakpointsPanel event table definition
 */

BEGIN_EVENT_TABLE( BreakpointsPanel, wxPanel )

////@begin BreakpointsPanel event table entries
   EVT_LIST_ITEM_ACTIVATED( bpID_BREAKPOINTLIST, BreakpointsPanel::OnBreakpointActivated )
   
////@end BreakpointsPanel event table entries

   EVT_LIST_KEY_DOWN( bpID_BREAKPOINTLIST, BreakpointsPanel::OnKeyDown )

   EVT_BREAKPOINT_EVENTS( BreakpointsPanel::OnBreakpointEvent )

   EVT_MENU( wxID_DELETE, BreakpointsPanel::OnDelete )
   EVT_MENU( tsID_BREAKPOINT_PROPERTIES, BreakpointsPanel::OnProperties )
   EVT_MENU( tsID_BREAKPOINT_GOTOSOURCE, BreakpointsPanel::OnGotoSource )
   EVT_MENU( tsID_SCRIPT_TOGGLEBREAKPOINT, BreakpointsPanel::OnToggle )

   EVT_UPDATE_UI( wxID_DELETE, BreakpointsPanel::OnUpdateUI )
   EVT_UPDATE_UI( tsID_BREAKPOINT_PROPERTIES, BreakpointsPanel::OnUpdateSingleUI )
   EVT_UPDATE_UI( tsID_BREAKPOINT_GOTOSOURCE, BreakpointsPanel::OnUpdateSingleUI )
   EVT_UPDATE_UI( tsID_SCRIPT_TOGGLEBREAKPOINT, BreakpointsPanel::OnUpdateToggleUI )

END_EVENT_TABLE()

/*!
 * BreakpointsPanel constructors
 */

BreakpointsPanel::BreakpointsPanel( )
{
   m_Icons = NULL;
}

BreakpointsPanel::BreakpointsPanel( wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, long style )
{
   m_Icons = NULL;
   Create( parent, id, pos, size, style );
}

BreakpointsPanel::~BreakpointsPanel()
{
   delete m_Icons;
}

/*!
 * BreakpointsPanel creator
 */

bool BreakpointsPanel::Create( wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, long style )
{
////@begin BreakpointsPanel member initialisation
   m_Toolbar = NULL;
   m_BreakList = NULL;
////@end BreakpointsPanel member initialisation
   

   m_Icons = new wxImageList( 16, 16, true );
   m_Icons->Add( ts_breakpoint16 );
   m_Icons->Add( ts_breakpointc16 );
   m_Icons->Add( ts_breakpoint_disabled16 );

////@begin BreakpointsPanel creation
   SetExtraStyle( GetExtraStyle() | wxWS_EX_BLOCK_EVENTS );
   wxPanel::Create( parent, id, pos, size, style | wxWANTS_CHARS );

   CreateControls();
////@end BreakpointsPanel creation

   SetLabel( SYMBOL_BREAKPOINTSPANEL_TITLE );

    return TRUE;
}

/*!
 * Control creation for BreakpointsPanel
 */

void BreakpointsPanel::CreateControls()
{    
////@begin BreakpointsPanel content construction
   BreakpointsPanel* itemPanel1 = this;

   wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxHORIZONTAL);
   itemPanel1->SetSizer(itemBoxSizer2);

   wxBoxSizer* itemBoxSizer3 = new wxBoxSizer(wxVERTICAL);
   itemBoxSizer2->Add(itemBoxSizer3, 1, wxGROW, 0);

   m_Toolbar = new tsToolBar( itemPanel1, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTB_FLAT|wxTB_HORIZONTAL|wxTB_NODIVIDER|wxNO_BORDER|wxCLIP_CHILDREN );
   m_Toolbar->SetToolPacking(0);
   m_Toolbar->SetToolBitmapSize(wxSize(16, 16));
   m_Toolbar->Realize();
   itemBoxSizer3->Add(m_Toolbar, 0, wxGROW|wxBOTTOM, 2);

   m_BreakList = new wxListCtrl( itemPanel1, bpID_BREAKPOINTLIST, wxDefaultPosition, wxSize(100, 100), wxLC_REPORT|wxLC_SORT_ASCENDING|wxLC_HRULES|wxLC_VRULES|wxSTATIC_BORDER|wxCLIP_CHILDREN );
   itemBoxSizer3->Add(m_BreakList, 1, wxGROW, 5);

////@end BreakpointsPanel content construction

   m_Toolbar->AddTool( tsID_DEBUG_NEWBREAKPOINT, _T( "New Breakpoint" ), ts_newbreak16, _T( "New Breakpoint (Ctrl+B)" ) );
   m_Toolbar->AddSeparator();
   m_Toolbar->AddTool( tsID_SCRIPT_TOGGLEBREAKPOINT, _T( "Disable" ), ts_breaktoggle16, _T( "Disable" ) );
   m_Toolbar->AddTool( wxID_DELETE, _T( "Delete" ), ts_delete16, _T( "Delete" ) );
   m_Toolbar->AddTool( tsID_BREAKPOINT_PROPERTIES, _T( "Properties" ), ts_breakproperties16, _T( "Properties" ) );
   m_Toolbar->AddTool( tsID_BREAKPOINT_GOTOSOURCE, _T( "Go To Source" ), ts_breakgoto16, _T( "Go To Source" ) );
   m_Toolbar->AddSeparator();
   m_Toolbar->AddTool( tsID_DEBUG_CLEARALLBREAKPOINTS, _T( "Delete All Breakpoints" ), ts_breakclearall16, _T( "Delete All Breakpoints (Ctrl+Shift+F9)" ) );
   m_Toolbar->AddTool( tsID_DEBUG_DISABLEALLBREAKPOINTS, _T( "Disable All Breakpoints" ), ts_breakdisableall16, _T( "Disable All Breakpoints" ) );
   m_Toolbar->Realize();

   m_BreakList->SetImageList( m_Icons, wxIMAGE_LIST_SMALL );
	m_BreakList->InsertColumn( 0, "Name", wxLIST_FORMAT_LEFT, 300 );
	m_BreakList->InsertColumn( 1, "Condition", wxLIST_FORMAT_LEFT, 125 );
	m_BreakList->InsertColumn( 2, "Hit Count", wxLIST_FORMAT_LEFT, 125 );
}

/*!
 * Should we show tooltips?
 */

bool BreakpointsPanel::ShowToolTips()
{
    return TRUE;
}

/*!
 * Get bitmap resources
 */

wxBitmap BreakpointsPanel::GetBitmapResource( const wxString& name )
{
    // Bitmap retrieval
////@begin BreakpointsPanel bitmap retrieval
   wxUnusedVar(name);
   return wxNullBitmap;
////@end BreakpointsPanel bitmap retrieval
}

/*!
 * Get icon resources
 */

wxIcon BreakpointsPanel::GetIconResource( const wxString& name )
{
    // Icon retrieval
////@begin BreakpointsPanel icon retrieval
   wxUnusedVar(name);
   return wxNullIcon;
////@end BreakpointsPanel icon retrieval
}

/*
void BreakpointsPanel::UpdateBreakpoints()
{
   wxASSERT( m_BreakList );

   wxASSERT( tsGetMainFrame() );
   if ( !tsGetMainFrame()->GetProjectDoc() ) {
      m_BreakList->DeleteAllItems();
      return;
   }

   const BreakpointArray& Breakpoints = tsGetMainFrame()->GetProjectDoc()->GetBreakpoints();

   m_BreakList->Freeze();
   m_BreakList->DeleteAllItems();

   for ( int i=0; i < Breakpoints.GetCount(); i++ ) {
      
      wxASSERT( Breakpoints[i] );
      wxString name;
      name << Breakpoints[i]->GetFile() << ", line " << Breakpoints[i]->GetLine();
      long item = m_BreakList->InsertItem( i, name );

      wxString condition = Breakpoints[i]->GetCondition();
      if ( condition.IsEmpty() )
         condition = "(no condition)";

      m_BreakList->SetItem( item, 1, condition );

      wxString pass;
      pass << Breakpoints[i]->GetPass();

      m_BreakList->SetItem( item, 2, pass );
   }

   m_BreakList->Thaw();
}
*/

void BreakpointsPanel::AddBreakpoint( Breakpoint* bp )
{
   wxASSERT( bp );
   wxASSERT( m_BreakList );

   long item = m_BreakList->InsertItem( m_BreakList->GetItemCount(), wxEmptyString );
   UpdateBreakpoint( item, bp );
}

void BreakpointsPanel::UpdateBreakpoint( long item, Breakpoint* bp )
{
   wxASSERT( bp );
   wxASSERT( m_BreakList );
   wxASSERT( item >= 0 );
   wxASSERT( item < m_BreakList->GetItemCount() );

   wxString name;
   name << bp->GetFile() << ", line " << bp->GetLine();
   m_BreakList->SetItem( item, 0, name );

   wxString condition = bp->GetCondition();
   if ( condition.IsEmpty() )
      condition = "(no condition)";

   m_BreakList->SetItem( item, 1, condition );

   wxString pass;
   if ( bp->GetPass() > 0 )
      pass << bp->GetPass();
   else 
      pass << "(break always)";

   m_BreakList->SetItem( item, 2, pass );

   m_BreakList->SetItemData( item, (long)bp );

   int image = 0;
   if ( !bp->GetEnabled() )
      image = 2;
   else if ( bp->HasCondition() )
      image = 1;

   m_BreakList->SetItemImage( item, image );
}

int BreakpointsPanel::GetSelected( BreakpointArray& selected )
{
   for ( int i=0; i < m_BreakList->GetItemCount(); i++ ) {
      if ( m_BreakList->GetItemState( i, wxLIST_STATE_SELECTED ) & wxLIST_STATE_SELECTED )
         selected.Add( (Breakpoint*)m_BreakList->GetItemData( i ) );
   }

   return (int)selected.GetCount();
}

void BreakpointsPanel::OnKeyDown( wxListEvent& event )
{
   if (  event.GetKeyCode() == WXK_DELETE ||
         event.GetKeyCode() == WXK_NUMPAD_DELETE )
   {
      OnDelete( wxCommandEvent() );     
      return;
   }

   event.Skip();
}

void BreakpointsPanel::OnDelete( wxCommandEvent& event )
{
   ProjectDoc* project = tsGetMainFrame()->GetProjectDoc();
   if ( !project )
      return;

   BreakpointArray selected;
   if ( GetSelected( selected ) <= 0 )
      return;

   wxASSERT( m_BreakList );
   long first = m_BreakList->FindItem( -1, (long)selected[0] );

   for ( int i=0; i < selected.GetCount(); i++ )
      project->DeleteBreakpoint( selected[i] );

   if ( m_BreakList->GetItemCount() <= 0 )
      return;

   first = wxMin( first, m_BreakList->GetItemCount()-1 );
   m_BreakList->SetItemState( first, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED );
}

void BreakpointsPanel::OnGotoSource( wxCommandEvent& event )
{
   BreakpointArray selected;
   if ( GetSelected( selected ) <= 0 )
      return;

   wxASSERT( tsGetMainFrame() );
   wxASSERT( selected[0] );
   tsGetMainFrame()->OpenFile( selected[0]->GetFile(), selected[0]->GetLine()-1 );
}

void BreakpointsPanel::OnProperties( wxCommandEvent& event )
{
   ProjectDoc* project = tsGetMainFrame()->GetProjectDoc();
   if ( !project )
      return;

   BreakpointArray selected;
   if ( GetSelected( selected ) <= 0 )
      return;

   // Copy the breakpoint and set the file path
   // as absolute for the dlg.
   Breakpoint copy( *selected[0] );

   wxASSERT( tsGetMainFrame() );
   BreakpointPropertyDlg dlg;
   dlg.Create( tsGetMainFrame(), &copy );
   if ( dlg.ShowModal() == wxID_OK ) {
      project->ChangeBreakpoint( selected[0], &copy );
   }
}

void BreakpointsPanel::OnToggle( wxCommandEvent& event )
{
   ProjectDoc* project = tsGetMainFrame()->GetProjectDoc();
   if ( !project )
      return;

   BreakpointArray selected;
   if ( GetSelected( selected ) <= 0 )
      return;

   // First decide if we're enabling or disabling.
   bool enable = false;
   for ( size_t i=0; i < selected.GetCount(); i++ ) {

      Breakpoint* bp = selected[ i ];
      wxASSERT( bp );
      enable |= bp->GetEnabled();
	}

   // Now apply the change.
   for ( size_t i=0; i < selected.GetCount(); i++ ) {

      Breakpoint* bp = selected[ i ];
      wxASSERT( bp );
      project->EnableBreakpoint( bp, !enable );
	}   
}

void BreakpointsPanel::OnUpdateToggleUI( wxUpdateUIEvent& event )
{
   ProjectDoc* project = tsGetMainFrame()->GetProjectDoc();
   if ( !project ) {
      event.Enable( false );
      return;
   }

   BreakpointArray selected;
   GetSelected( selected );

   bool enabled = false;
   for ( size_t i=0; i < selected.GetCount(); i++ ) {

      Breakpoint* bp = selected[ i ];
      wxASSERT( bp );
      enabled |= bp->GetEnabled();
	}

   event.Enable( selected.GetCount() > 0 );

   wxASSERT( m_Toolbar );
   m_Toolbar->SetToolShortHelp( tsID_SCRIPT_TOGGLEBREAKPOINT, enabled ? "Disable" : "Enable" );
}

void BreakpointsPanel::OnUpdateUI( wxUpdateUIEvent& event )
{
   event.Enable( m_BreakList->GetSelectedItemCount() > 0 );
}

void BreakpointsPanel::OnUpdateSingleUI( wxUpdateUIEvent& event )
{
   event.Enable( m_BreakList->GetSelectedItemCount() == 1 );
}

void BreakpointsPanel::OnBreakpointEvent( BreakpointEvent& event )
{
   // TODO: This class depends on the breakpoint pointer 
   // not changing from event to event.  I should move to
   // some sort of breakpoint id method.

   if ( event.GetType() == BreakpointEvent::TYPE_ADD )
      AddBreakpoint( event.GetBreakpoint() );

   else if ( event.GetType() == BreakpointEvent::TYPE_REMOVE ) {

      wxASSERT( m_BreakList );
      long index = m_BreakList->FindItem( -1, (long)event.GetBreakpoint() );
      if ( index != wxNOT_FOUND )
         m_BreakList->DeleteItem( index );
   }

   else if ( event.GetType() == BreakpointEvent::TYPE_MOVED ||
             event.GetType() == BreakpointEvent::TYPE_CHANGED ) {

      wxASSERT( m_BreakList );
      long index = m_BreakList->FindItem( -1, (long)event.GetBreakpoint() );
      if ( index == wxNOT_FOUND )
         AddBreakpoint( event.GetBreakpoint() );
      else
         UpdateBreakpoint( index, event.GetBreakpoint() );
   }

   else {

      wxASSERT( false );
   }
}

/*!
 * wxEVT_COMMAND_LIST_ITEM_ACTIVATED event handler for bpID_BREAKPOINTLIST
 */

void BreakpointsPanel::OnBreakpointActivated( wxListEvent& event )
{
   ProjectDoc* project = tsGetMainFrame()->GetProjectDoc();
   if ( !project )
      return;

   Breakpoint* bp = (Breakpoint*)event.GetData();
   wxASSERT( bp );

   // HACK: We should probably move this to a 
   // mouse double click handler.
   wxPoint pt = wxGetMousePosition();
   pt = m_BreakList->ScreenToClient( pt );

   int flags = 0;
   long hit = m_BreakList->HitTest( pt, flags );
   if ( hit == event.GetIndex() && flags & wxLIST_HITTEST_ONITEMICON ) {

      project->ToggleBreakpoint( bp->GetFile(), bp->GetLine(), true );
      return;
   }

   wxASSERT( tsGetMainFrame() );
   tsGetMainFrame()->OpenFile( bp->GetFile(), bp->GetLine()-1 );
}

bool BreakpointsPanel::ProcessEvent(wxEvent& event)
{
   // HACK:  In order to override the behavior
   // in wxDocManager for close and close all
   // we're forcing those events to go thru us
   // only and not to the doc manager.
   if (  event.GetId() == tsID_DEBUG_NEWBREAKPOINT ||
         event.GetId() == tsID_DEBUG_CLEARALLBREAKPOINTS ||
         event.GetId() == tsID_DEBUG_DISABLEALLBREAKPOINTS ) 
   {
      wxASSERT( tsGetMainFrame() );
      return tsGetMainFrame()->ProcessEvent( event );
   }

   if ( event.GetEventType() == wxEVT_KEY_DOWN )
   {
      int foo = 1;
   }

   return wxPanel::ProcessEvent( event );
}

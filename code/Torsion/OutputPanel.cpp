// Torsion TorqueScript IDE - Copyright (C) Sickhead Games, LLC
// This file is subject to the terms and conditions defined in
// file 'LICENSE.txt', which is part of this source code package.

// Generated by DialogBlocks (unregistered), 28/01/2006 17:35:50

#if defined(__GNUG__) && !defined(NO_GCC_PRAGMA)
#pragma implementation "OutputPanel.h"
#endif

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

////@begin includes
////@end includes

#include "OutputPanel.h"
#include "TorsionApp.h"
#include "MainFrame.h"
#include "Debugger.h"
#include "tsToolBar.h"
#include "Icons.h"

#include <wx/filedlg.h>
#include <wx/ffile.h>

////@begin XPM images
////@end XPM images

/*!
 * OutputPanel type definition
 */

IMPLEMENT_DYNAMIC_CLASS( OutputPanel, wxPanel )

/*!
 * OutputPanel event table definition
 */

BEGIN_EVENT_TABLE( OutputPanel, wxPanel )

////@begin OutputPanel event table entries
   EVT_TEXT_ENTER( opID_CONSOLECMD, OutputPanel::OnConsoleCommand )
   EVT_UPDATE_UI( opID_CONSOLECMD, OutputPanel::OnConsoleCommandUpdateUI )

////@end OutputPanel event table entries

   EVT_MENU( tsID_OUTPUT_NEXTERROR, OnNextError )
   EVT_MENU( tsID_OUTPUT_PREVERROR, OnPrevError )
   EVT_MENU( tsID_OUTPUT_CLEAR, OnClear )
   EVT_MENU( tsID_OUTPUT_SAVE, OnSaveFile )
   EVT_MENU( tsID_OUTPUT_LOAD, OnLoadFile )

	EVT_UPDATE_UI( tsID_OUTPUT_ERRORS, OnErrorsUpdateUI )
	EVT_UPDATE_UI( tsID_OUTPUT_NEXTERROR, OnErrorsUpdateUI )
	EVT_UPDATE_UI( tsID_OUTPUT_PREVERROR, OnErrorsUpdateUI )
	EVT_UPDATE_UI( tsID_OUTPUT_CLEAR, OnClearUpdateUI )
	EVT_UPDATE_UI( tsID_OUTPUT_SAVE, OnClearUpdateUI )

   /*
   EVT_RIGHT_UP( OnRightClick )
   
   EVT_SET_CURSOR( OnSetCursor ) 

   EVT_MENU( tsID_GOTOFILE, OnGotoFile )
   EVT_UPDATE_UI( tsID_GOTOFILE, OnUpdateGotoFile )
   EVT_MENU( tsID_CLEARALL, OnClearAll )
   EVT_UPDATE_UI( tsID_CLEARALL, OnUpdateClearAll )
   EVT_MENU( tsID_COPYLINE, OnCopyLines )
   EVT_UPDATE_UI( tsID_COPYLINE, OnUpdateCopyLines )
   EVT_MENU( tsID_FINDCANCEL, OnStopFind )
   EVT_UPDATE_UI( tsID_FINDCANCEL, OnUpdateStopFind )
   */

   END_EVENT_TABLE()

/*!
 * OutputPanel constructors
 */

OutputPanel::OutputPanel( )
{
}

OutputPanel::OutputPanel( wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, long style )
{
    Create(parent, id, pos, size, style);
}

/*!
 * OutputPanel creator
 */

bool OutputPanel::Create( wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, long style )
{
////@begin OutputPanel member initialisation
   m_ToolBar = NULL;
   m_Output = NULL;
   m_ScrollMap = NULL;
   m_CmdLine = NULL;
////@end OutputPanel member initialisation
   m_ErrorText = NULL;

////@begin OutputPanel creation
   SetExtraStyle(GetExtraStyle()|wxWS_EX_BLOCK_EVENTS);
   wxPanel::Create( parent, id, pos, size, style );

   CreateControls();
   if (GetSizer())
   {
      GetSizer()->SetSizeHints(this);
   }
////@end OutputPanel creation

   SetLabel( SYMBOL_OUTPUTPANEL_TITLE );

   return true;
}

/*!
 * Control creation for OutputPanel
 */

void OutputPanel::CreateControls()
{    
////@begin OutputPanel content construction
   OutputPanel* itemPanel1 = this;

   wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxHORIZONTAL);
   itemPanel1->SetSizer(itemBoxSizer2);

   wxBoxSizer* itemBoxSizer3 = new wxBoxSizer(wxVERTICAL);
   itemBoxSizer2->Add(itemBoxSizer3, 1, wxGROW, 0);

   m_ToolBar = new tsToolBar( itemPanel1, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTB_FLAT|wxTB_HORIZONTAL|wxTB_NODIVIDER|wxNO_BORDER|wxCLIP_CHILDREN );
   m_ToolBar->SetToolPacking(0);
   m_ToolBar->SetToolBitmapSize(wxSize(16, 16));
   m_ToolBar->Realize();
   itemBoxSizer3->Add(m_ToolBar, 0, wxGROW|wxLEFT|wxBOTTOM, 2);

   wxFlexGridSizer* itemFlexGridSizer5 = new wxFlexGridSizer(2, 2, 0, 0);
   itemFlexGridSizer5->AddGrowableRow(0);
   itemFlexGridSizer5->AddGrowableCol(0);
   itemBoxSizer3->Add(itemFlexGridSizer5, 1, wxGROW, 0);

   m_Output = new OutputCtrl( itemPanel1, wxID_ANY, _T(""), wxDefaultPosition, wxDefaultSize, wxTE_MULTILINE|wxTE_READONLY|wxTE_RICH2|wxSTATIC_BORDER|wxTE_DONTWRAP );
   itemFlexGridSizer5->Add(m_Output, 1, wxGROW|wxGROW, 0);

   m_ScrollMap = new ScrollMapCtrl( itemPanel1, wxID_ANY, wxDefaultPosition, wxSize(16, -1), wxNO_BORDER|wxCLIP_CHILDREN );
   itemFlexGridSizer5->Add(m_ScrollMap, 0, wxGROW|wxGROW|wxLEFT|wxFIXED_MINSIZE, 2);

   wxString* m_CmdLineStrings = NULL;
   m_CmdLine = new wxComboBox( itemPanel1, opID_CONSOLECMD, _T(""), wxDefaultPosition, wxDefaultSize, 0, m_CmdLineStrings, wxCB_DROPDOWN );
   itemFlexGridSizer5->Add(m_CmdLine, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxTOP, 3);

   itemFlexGridSizer5->Add(8, 5, 0, wxALIGN_LEFT|wxGROW, 0);

////@end OutputPanel content construction

   m_Output->SetBestFittingSize( wxSize( 0, 0 ) );

   m_ErrorText = new wxStaticText( m_ToolBar, tsID_OUTPUT_ERRORS, "No Errors!" ); //, wxDefaultPosition, wxDefaultSize, ( toolBar, tsID_CONFIGCOMBO, "", wxDefaultPosition, wxSize( 160, wxDefaultCoord), 0, NULL, wxSTATIC_BORDER | wxCB_DROPDOWN | wxCB_READONLY | wxCB_SORT );
   m_ToolBar->AddControl( m_ErrorText );
   m_ToolBar->AddSeparator();
   m_ToolBar->AddTool( tsID_OUTPUT_PREVERROR, _T( "Previous Error" ), ts_errorprev16, _T( "Previous Error" ) );
   m_ToolBar->AddTool( tsID_OUTPUT_NEXTERROR, _T( "Next Error" ), ts_errornext16, _T( "Next Error" ) );
   m_ToolBar->AddSeparator();
   m_ToolBar->AddTool( tsID_OUTPUT_LOAD, _T( "Open Output..." ), ts_open_document16, _T( "Open Output..." ) );
   m_ToolBar->AddTool( tsID_OUTPUT_SAVE, _T( "Save Output..." ), ts_save16, _T( "Save Output..." ) );
   m_ToolBar->AddTool( tsID_OUTPUT_CLEAR, _T( "Clear" ), ts_outputclear16, _T( "Clear" ) );
   m_ToolBar->Realize();
   
   m_ScrollMap->SetScrollWindow( m_Output );
}

void OutputPanel::OnErrorsUpdateUI( wxUpdateUIEvent& event )
{
   wxASSERT( m_Output );
   const ErrorArray& errors = m_Output->GetErrors();
   event.Enable( errors.size() > 0 );
}

void OutputPanel::OnClearUpdateUI( wxUpdateUIEvent& event )
{
   wxASSERT( m_Output );
   //event.Enable( m_Output->GetLastPosition() > 0 );
}

void OutputPanel::OnNextError( wxCommandEvent& event )
{
   wxASSERT( m_Output );
   const ErrorArray& errors = m_Output->GetErrors();

   wxASSERT( m_Output );
   int line = m_Output->GetSelected();
   if ( line < 0 )
      line = m_Output->LineFromPosition( m_Output->GetCurrentPos() );

   for ( size_t i=0; i < errors.size(); i++ )
   {
      ScriptError* error = errors[i];
      if ( error->row > line )
      {
         m_Output->ActivateLine( error->row, false );
         return;
      }
   }

   // Start over and beep.
   MessageBeep( MB_ICONASTERISK );
   ScriptError* error = errors.front();
   m_Output->ActivateLine( error->row, false );
}

void OutputPanel::OnPrevError( wxCommandEvent& event )
{
   wxASSERT( m_Output );
   const ErrorArray& errors = m_Output->GetErrors();

   wxASSERT( m_Output );
   int line = m_Output->GetSelected();
   if ( line < 0 )
      line = m_Output->LineFromPosition( m_Output->GetCurrentPos() );

   for ( int i=(int)errors.size()-1; i >= 0; i-- )
   {
      ScriptError* error = errors[i];
      if ( error->row < line )
      {
         m_Output->ActivateLine( error->row, false );
         return;
      }
   }

   // Start over and beep.
   MessageBeep( MB_ICONASTERISK );
   ScriptError* error = errors.back();
   m_Output->ActivateLine( error->row, false );
}

void OutputPanel::OnClear( wxCommandEvent& event )
{
   Clear();
}

void OutputPanel::OnSaveFile( wxCommandEvent& event )
{
   wxString path = wxFileSelector( "Choose a name for this log", 
      wxEmptyString, wxEmptyString, wxEmptyString, 
      "Log files (*.log)|*.log|Text files (*.txt)|*.txt",
      wxFD_SAVE | wxFD_OVERWRITE_PROMPT, this );
   
   if ( path.IsEmpty() )
      return;

   // Do it!
   wxASSERT( m_Output );
   m_Output->SaveFile( path );
}

void OutputPanel::OnLoadFile( wxCommandEvent& event )
{
   wxString path = wxFileSelector( "Choose a log file to open", 
      wxEmptyString, wxEmptyString, wxEmptyString, 
      "Log files (*.log)|*.log|Text files (*.txt)|*.txt",
      wxFD_OPEN | wxFD_FILE_MUST_EXIST, this );
   
   if ( path.IsEmpty() )
      return;

   wxFFile file( path );
   if ( !file.IsOpened() )
      return;

   Clear();

   wxASSERT( m_Output );
   wxString output;
   file.ReadAll( &output );
   m_Output->AppendText( output );

   wxASSERT( m_ScrollMap );
   m_ScrollMap->SetRange( m_Output->GetLineCount() );

   // Did we have new errors?
   wxASSERT( m_Output );
   const ErrorArray& errors = m_Output->GetErrors();
   if ( errors.size() > 0 ) 
   {
      wxString text;
      text << (unsigned int)errors.size() << " Error(s)";
      m_ErrorText->SetLabel( text );
      m_ToolBar->Realize();

      //wxColour warnColor( 255, 128, 0 );

      for ( size_t i=0; i < errors.size(); i++ )
      {
         wxString tip;
         tip << errors[i]->file << "(" << errors[i]->line << ")\r\n" << errors[i]->error;
         //if ( errors[i]->warning )
         //   m_ScrollMap->AddItem( errors[i]->row, warnColor, tip );
         //else
            m_ScrollMap->AddItem( errors[i]->row, *wxRED, tip );
      }
   }

   // Adding text can turn scrollbars on and will 
   // screw up the layout on the flex grid.
   Layout();
}

void OutputPanel::Clear()
{
   wxASSERT( m_Output );
   m_Output->Clear();
   wxASSERT( m_ScrollMap );
   m_ScrollMap->SetRange( 0 );
   wxASSERT( m_ErrorText );
   m_ErrorText->SetLabel( "No Errors!" );
   m_ToolBar->Realize();
}

void OutputPanel::AppendText( const wxString& text )
{
   wxASSERT( m_Output );

   const ErrorArray& errors = m_Output->GetErrors();
   size_t prev = errors.size();

   m_Output->AppendText( text );

   wxASSERT( m_ScrollMap );
   m_ScrollMap->SetRange( (int)m_Output->GetLineCount() );

   // Did we have new errors?
   if ( prev != errors.size() ) 
   {
      wxString text;
      text << (int)errors.size() << " Error(s)";
      m_ErrorText->SetLabel( text );
      m_ToolBar->Realize();

      for ( size_t i=prev; i < errors.size(); i++ )
      {
         wxString tip;
         tip << errors[i]->file << "(" << errors[i]->line << ")\n" << errors[i]->error;
         m_ScrollMap->AddItem( errors[i]->row, *wxRED, tip );
      }
   }

   // Adding text can turn scrollbars on and will 
   // screw up the layout on the flex grid.
   Layout();
}

/*!
 * Should we show tooltips?
 */

bool OutputPanel::ShowToolTips()
{
    return true;
}

/*!
 * Get bitmap resources
 */

wxBitmap OutputPanel::GetBitmapResource( const wxString& name )
{
    // Bitmap retrieval
////@begin OutputPanel bitmap retrieval
   wxUnusedVar(name);
   return wxNullBitmap;
////@end OutputPanel bitmap retrieval
}

/*!
 * Get icon resources
 */

wxIcon OutputPanel::GetIconResource( const wxString& name )
{
    // Icon retrieval
////@begin OutputPanel icon retrieval
   wxUnusedVar(name);
   return wxNullIcon;
////@end OutputPanel icon retrieval
}

/*!
 * wxEVT_COMMAND_TEXT_ENTER event handler for ID_COMBOBOX
 */
void OutputPanel::OnConsoleCommand( wxCommandEvent& event )
{
   wxASSERT( m_CmdLine == event.GetEventObject() );

   if ( tsGetDebugger()->IsRunning() && !tsGetDebugger()->IsAtBreakpoint() ) 
		tsGetDebugger()->Eval( m_CmdLine->GetLabel() );

   // Stick the command into the list.
   m_CmdLine->Insert( m_CmdLine->GetLabel(), 0 );
	m_CmdLine->SetValue( wxEmptyString );
   while( m_CmdLine->GetCount() > 19 ) {
      m_CmdLine->Delete( m_CmdLine->GetCount()-1 );
   }
}

/*!
 * wxEVT_UPDATE_UI event handler for ID_COMBOBOX
 */

void OutputPanel::OnConsoleCommandUpdateUI( wxUpdateUIEvent& event )
{
   event.Enable( tsGetDebugger()->IsRunning() && !tsGetDebugger()->IsAtBreakpoint() );
}

const ErrorArray& OutputPanel::GetErrors() const
{
   wxASSERT( m_Output );
   return m_Output->GetErrors();
}

